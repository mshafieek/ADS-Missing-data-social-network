```{r}
devtools::install_github("TilburgNetworkGroup/remify")
devtools::install_github("TilburgNetworkGroup/remstats")
devtools::install_github("gerkovink/mice@match_conditional")
```

```{r}
library(mice)     # for imputation and amputation
library(purrr)    # for functional programming
library(furrr)    # for functional futures
library(magrittr) # for pipes
library(dplyr)    # for data manipulation
library(tibble)   # for tibbles
library(remstats) # for REM statistics
library(remify)
library(data.table)
library(remstimate) # for   REM
library(survival)
library(relevent)
```

```{r}
set.seed(123)
```


```{r}
##### Load data

load("UUsummerschool.rdata")

apollo <- as_tibble(PartOfApollo_13)

```

##### renaming columns to work with remify
```{r}
setnames(apollo, old = c('sender','receiver'), 
         new = c('actor1','actor2'))
```

```{r}
whichcol <- c("", "actor2", "actor1")
names(whichcol) <- colnames(apollo)

# use the custom pmm method
method <- make.method(apollo)
method[c(2,3)] <- "pmm.conditional"

```

##### Creating missing data
```{r}

##### Missing pattern
pattern <- matrix(c(1,0,1,1,1,0), nrow=2, byrow=TRUE)

##### predictor matrix
predictormatrix <- matrix(c(0,0,0,0,0,1,0,1,0), nrow=3, byrow=TRUE)


MCAR<- apollo %>% 
      ampute(prop = .5, 
             mech = "MCAR",
             patterns = pattern)

MCAR <- MCAR$amp %>%
  mice(m = 5,
       maxit = 5,
       method = method,
       whichcolumn = whichcol,
       predictorMatrix = predictormatrix,
       print = FALSE)

##### Model-based finite populations
mbased_finite_apollo <- list(
  MCAR = 
    apollo %>% 
      ampute(prop = .5, 
             mech = "MCAR",
             patterns = pattern) %>% .$amp %>%
      mice(m = 5, 
           maxit = 5,
           method = method,
           whichcolumn = whichcol,
           predictorMatrix = predictormatrix,
           print = FALSE) %>%
    complete("all"),
  MAR = 
    apollo %>% 
      ampute(prop = .5, 
             mech = "MAR", 
             patterns = pattern,
             type = "RIGHT") %>% .$amp %>% 
      mice(m = 5, 
           maxit = 5,
           method = method,
           whichcolumn = whichcol,
           predictorMatrix = predictormatrix,
           print = F) %>%
    complete("all"))
```

#### REM statistics
```{r}
effects <- ~ -1 + outdegreeReceiver() + indegreeSender() + reciprocity()
rehObject <- remify(apollo, model = "tie")

statsObject <- remstats(rehObject, tie_effects = effects)

dimnames(statsObject)

attr(statsObject, 'riskset')

reciprocity <- as.vector(statsObject[,,3])

outdegreeReceiver <- as.vector(statsObject[,,2])

indegreeSender <- as.vector(statsObject[,,1])

head(indegreeSender)
```

#### creating dataframe for coxph
```{r}
risk_sets <- attr(statsObject, "riskset")
risk_sets <- risk_sets %>% select(-'id')

time <- apollo$time

## combine dataframes
combined <- merge(risk_sets, time, by = NULL)
combined <- combined %>% rename("time" = "y")

## creating the status column
combined$status <-  ifelse(combined$sender == apollo$actor1 & combined$receiver == apollo$actor2 & combined$time == apollo$time, 1, 0)

###### REM analysis on completed data sets of MCAR and MAR
```{r}

run_coxph <- function(df) {
  rehObject <- remify(as.data.frame(df), model = "tie")
  statsObject <- remstats(rehObject, tie_effects = effects)
  
  reciprocity <- as.vector(statsObject[,,3])
  outdegreeReceiver <- as.vector(statsObject[,,1])
  indegreeSender <- as.vector(statsObject[,,2])
  
  data <- cbind(combined, reciprocity, outdegreeReceiver, indegreeSender)
  
  coxph(Surv(time, status) ~ reciprocity + indegreeSender + outdegreeReceiver, data = data)
}

###### running the function on all completed datasets


Results <- mbased_finite_apollo %>% 
  map(~.x %>% # for every missingness mechanism
        map(~.x %$%
              with(.x, run_coxph(.x))
            ) %>%
        pool()
  )


Results %>%
  map(~.x %>%
        .$pooled %>% # extract table of pooled coefficients
          mutate(true = True$coefficients, # add true
                 df = m-1,  # correct df
                 riv = Inf, # correct riv
                 std.error = sqrt(t), # standard error
                 statistic = estimate / std.error, # test statistic
                 p.value = 2 * (pt(abs(statistic), 
                                   pmax(df, 0.001), 
                                   lower.tail = FALSE)), # correct p.value
                 `2.5 %` = estimate - qt(.975, df) * std.error, # lower bound CI
                 `97.5 %` = estimate + qt(.975, df) * std.error, # upper bound CI
                 cov = `2.5 %` < true & true < `97.5 %`, # coverage
                 bias = estimate - true) %>% # bias
          select(term, m, true, estimate, std.error, statistic, p.value, 
                 riv, `2.5 %`, `97.5 %`, cov, bias) %>% 
          column_to_rownames("term") # `term` as rownames
    )
```
