---
title: "Thesis Project"
author: "Kasper Hermanns"
date: "2024-05-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading packages

Here we load all the packages. 

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

# The needed packages, constantly updated
packages <- c("mice","purrr","furrr","dplyr","tibble","remify","remstats","relevent","sna","magrittr","survival","imputeTS","survival")

# library("devtools")
# devtools::install_github("TilburgNetworkGroup/remify")
# devtools::install_github("gerkovink/mice@match_conditional_current") 
# devtools::install_github("TilburgNetworkGroup/remstats")

lapply(packages, library,  warn.conflicts = FALSE, character.only=TRUE) # load all the packages


```

## Load in the data

Remove the irrelevant data and rename the 'PartOfApollo_13' data

```{r echo=TRUE, , echo=FALSE}

rm(list=ls())

# set working directory to be the current directory
setwd("~/Applied Data Science (Master)/Thesis 2024/Code")


# Load the data, rename Apollo data and remove the rest of the data
load("UUsummerschool.Rdata")
Apollo <- PartOfApollo_13  %>% 
  rename(
    actor1 = sender,        # These are renamed actor1 and actor2 to match the naming from the 'remify' function used later
    actor2 = receiver
  ) 

rm(Class, PartOfApollo_13, Twitter_data_rem3, WTCPoliceCalls, ClassIntercept, 
   ClassIsFemale, ClassIsTeacher, WTCPoliceIsICR)

head(Apollo)
tail(Apollo)
summary(Apollo)
str(Apollo)

N <- nrow(Apollo)

# Set this as the seed to get the same results every time
set.seed(123)

```


## Visualize Network

With this full data, show the network and its connections


```{r echo=TRUE, , echo=FALSE}

# Make sociomatrix from the Dyadic 
ApolloNet <- as.sociomatrix.eventlist(Apollo,19)

# Make covariate denoting which actors are astronauts or not (last 3 are astronauts)
IsAstronaut <- vector("logical",19)
IsAstronaut[17:19] <- TRUE
IsAstronaut

# And plot it using gplot
gplot(ApolloNet ,vertex.col=ifelse(IsAstronaut ,"blue","red"),
      vertex.sides=3+IsAstronaut ,vertex.cex=2, edge.lwd= ApolloNet ^0.5)


gplot(ApolloNet, jitter = TRUE, pad = .075,
              mode = "target", ,vertex.col=ifelse(IsAstronaut ,"blue","red"),
              displaylabels = TRUE, label.pos = 0, label.cex = .75,
              boxed.labels = TRUE, label.pad = .5, 
              displayisolates = FALSE, vertex.cex=.6,
              arrowhead.cex = .75, edge.lwd = -.75, edge.col = "gray") 

```


## Analyse the full dataset to get the true coefficients

Now that there is no missingness (yet), run the analysis to get the true values for the appropriate statistics:
  1. Reciprocity              (PSAB-BA)
  2. Indegree sender          (NIDSnd) 
  3. Outdegree receiver       (NODRec)
  
These are the endogenous statistics used for analysis last year, will be changed and updated.

```{r echo=TRUE}

# These will be the effects that will be studied 
effects <- ~ -1 + reciprocity(scaling = ("std")) + indegreeSender() + outdegreeReceiver()

# Get the event history from the network
true_REH <- remify(Apollo,  model = 'tie')

# Calculate stats from this REH
true_stats <- remstats(true_REH, tie_effects = effects)

# True
coxp


```


## Prepare data for amputing

 <font size="0.1"> am puting these ***** in your ***** </font>

```{r echo=TRUE}

set.seed(123)

# Add order column to Apollo, helps sorting later since the time column needs to be in order
Apollo$order <- 1:nrow(Apollo)

# Check how many unique dyads and actors are in the original dataset
remify(Apollo, model = "tie") %>% dim() # 16 actors and 240 dyads

# Need to make sure that the amputed datasets retain those 16 actors and 240 dyads, otherwise they can't be imputed
# For that we need a random base set of (e.g. 1300) rows that we always keep
M <- 1300
base_indic <- sort(sample(1:nrow(Apollo),M))  

# Test if those still retain all the actors and dyads
remify(Apollo[(base_indic),],model = "tie") %>% dim()
# Success! These indices still have all 16 actors and 240 dyads. These can be used as the base set.

# Split the dataset in 2. rest_Apollo can be amputed in whatever way and then combined with base_Apollo and arranged correctly.
base_Apollo <- Apollo[base_indic,]
rest_Apollo <- Apollo[-base_indic,]

comb_Apollo <- rbind(base_Apollo,rest_Apollo) %>%  arrange(order)


```

## Props for the Heist Rocker

This is the function to fix the proportion issue that arose from only running ampute on a part of the dataset

```{r echo=TRUE}

# Lets try out amputing with default settings, just to see what happens. Of course we only ampute rest_Apollo and then combine
MCAR.1 <- ampute(rest_Apollo,prop = .3, mech = "MCAR")$amp
md.pattern(MCAR.1)

Apollo_miss1 <- rbind(base_Apollo,MCAR.1) %>%  arrange(order)
md.pattern(Apollo_miss1)

# Lets check if the proportion is correct. (Spoiler: Its not)
sum(!complete.cases(Apollo_miss1)) / N
# Wait this is not the proportion we want! Darn it

## Problem!:
# Since the amputing is done on just a part of the dataset, the missingness proportion will not be accurate to the prop value given to the ampute function. This has to be fixed like this:

recalc_prop <- function (desired_prop, totalN, partN){
  rowsMissing <-  totalN * desired_prop # This is the amount of rows that should be missing in the full dataset
  needed_prop <- rowsMissing / partN  # This is the prop missing needed in the partial dataset to recreate the correct prop level
  return(needed_prop)
}

# Now we try this again with the recalculated prop
MCAR.1 <- ampute(rest_Apollo,prop = recalc_prop(0.3,N,N-M), mech = "MCAR")$amp
md.pattern(MCAR.1)

comb_Apollo <- rbind(base_Apollo,MCAR.1) %>%  arrange(order)
md.pattern(Apollo_miss1)

sum(!complete.cases(Apollo_miss1)) / N
# This is better!

```


## Amputer? I hardly know her!

Here we start amputing the rest_Apollo in a couple different ways. The settings will be:

- Missingness proportion (rows with missing values) will be 0.3
- We will have all possible combinations of time, actor1 and actor2 as patterns
- The frequency of each pattern will differ
- The mechanism will be MAR.
- Weights will be standard
- Type will differ between pattern, mostly RIGHT-tailed though.

```{r echo=TRUE}

# These are the missingness patterns, the indices column will never be missing of course
myPatterns <- matrix(c(0,0,0,1,
                     0,0,1,1,
                     0,1,0,1,
                     1,0,0,1,
                     1,1,0,1,
                     1,0,1,1,
                     0,1,1,1),
                   nrow = 7,ncol=4,byrow = T)

MCAR.1 <- ampute(rest_Apollo,prop = recalc_prop(.3,N,N-M), patterns = myPatterns, mech = "MCAR")$amp
Apollo_miss1 <- rbind(base_Apollo,MCAR.1) %>%  arrange(order)
md.pattern(Apollo_miss1)

```


## Mice Mice Baby 

Now we will use multiple imputation with mice to impute those missing values we created above. 


The method will be pmm_conditional, which makes sure that actor1 and actor2 can't be the same id.
Imputing the missing time values will be more complicated, since the correct order needs to be maintained

For now we just interpolate the NA's in time before running MICE. 

```{r echo=TRUE}

# Set these as the methods, time will not have a method as it will be interpolated before running MICE so will have no NA
myMethods1 <- c("","pmm.conditional","pmm.conditional","") 

cond_col <- c("","actor2","actor1","") # Need to specify on which columns each pmm.conditional is conditioned on.
names(cond_col) <- colnames(Apollo)


## Interpolate time before running MICE, this is done by taking the average timepoint(s) between the timepoints before and after the NA(s)
Apollo_time_full <- Apollo_miss1 %>% mutate(time = na_interpolation(Apollo_miss1$time))
is.unsorted(Apollo_time_full$time)
md.pattern(Apollo_time_full)
# as you can see it is sorted and no longer any missing values for time.

# Now we set the predictor matrix correctly etc.
imp0 <- mice(Apollo_time_full,printFlag = F)

predMat1 <- imp0$predictorMatrix
predMat1
predMat1[,'order'] <- 0          # Order should not help predict actor1 and actor2
predMat1['time',] <- predMat1['order',] <- 0  # Other variables don't predict order (Superfluous, since it will not be imputed anyway but looks nicer)
predMat1

# And we run MICE
imp1 <- mice(Apollo_time_full, m = 1, method = myMethods1, predictorMatrix = predMat1, whichcolumn = cond_col ,printFlag = F)

Apollo_amp1 <- complete(imp1)
is.unsorted(Apollo_amp1$time)
is.unsorted(Apollo_amp1$order)



```


## Analysis on amputed dataset

The single amputed dataset will be analysed here, to try out how the analysis works.


```{r echo=TRUE}




```



# Mice to meet you!

Here we try some other methods in MICE to get good imputations for time.

```{r echo=TRUE}

# Set these as the methods, time will be predicted with norm.predict
myMethods2 <- c("norm.predict","pmm.conditional","pmm.conditional","") 

imp0_2 <- mice(Apollo_miss1,printFlag = F)

predMat2 <- imp0_2$predictorMatrix
predMat2
predMat2[,'order'] <- 0          # Order should not help predict actor1 and actor2
predMat2['time',] <- c(0,0,0,1)  # Lets try regressing time just on the order variable, this should keep the correct order intact.
predMat2['order',] <- 0          # Other variables don't predict order (Superfluous, since it will not be imputed anyway but looks nicer)
predMat2

imp1_2 <- mice(Apollo_miss1, m = 1, method = myMethods2, predictorMatrix = predMat2, whichcolumn = cond_col ,printFlag = F)

test_2 <- complete(imp1_2)
is.unsorted(test_2$time)

### IS UNSORTED, SO IT DOES NOT KEEP THE ORDER INTACT CORRECTLY. LOOK INTO FIX.

test2 <- test %>% arrange(time)
### SEE order: (101,102,111)

### TRY SETTING THE TIMEPOINT OF 1 TO 0 AS BASELINE AND TRY AGAIN (SUBTRACT TIME AT 1 OF EVERY TIMEPOINT)

baseline_time <- Apollo[1,1]
baseline_time

test_miss1 <- Apollo_miss1 %>% mutate(time = time - baseline_time)
md.pattern(test_miss1)
head(test_miss1)

imp1_2 <- mice(Apollo_miss1, m = 1, method = myMethods2, predictorMatrix = predMat2, whichcolumn = cond_col ,printFlag = F)

test_2 <- complete(imp1_2)
is.unsorted(test_2$time)

test2 <- test %>% arrange(time)

### STILL DIDNT WORK, TRY SETTING ORDER TO NUMERIC

test_miss1$order <- as.numeric(test_miss1$order)
str(test_miss1)

mp_test <- mice(test_miss1, m = 1, method = myMethods, predictorMatrix = predMat, whichcolumn = cond_col ,printFlag = F)
test <- complete(imp_test)
is.unsorted(test$time)

test2 <- test %>% arrange(time)

```

































































