---
title: "Thesis missing data and relational event model"
output: html_document
date: "2023-05-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Libraries
```{r}
library(mice)     
library(purrr)    
library(furrr)    
library(mvtnorm)  
library(magrittr) 
library(dplyr)    
library(tibble)   
library(relevent)
library(Epi)
library(ggplot2)
library(sna)
library(remify)
library(RSiena)
library(rem)
library(survival)
library(remstats)
library(remify)
library(igraph)
library(visNetwork)
```

```{r}
devtools::install_github("TilburgNetworkGroup/remstats@v3.1.0")
devtools::install_github(repo = "TilburgNetworkGroup/remstimate")
devtools::install_github("TilburgNetworkGroup/remify")
```

# Explore the data

```{r}
load("~/Master Applied Data Science/Thesis/Thesis/UUsummerschool.Rdata")
str(PartOfApollo_13)
summary(PartOfApollo_13)
```
## Visualize the network

```{r}
#build the network
edges<-data.frame(from=c(as.character(PartOfApollo_13[,2])),to=c(as.character(PartOfApollo_13[,3])))
Apollo<-graph_from_data_frame(edges,directed = TRUE)
summary(Apollo)

#function to visualize the real network (with interaction)
set.seed(100)
Apollo_interactive_layout<-visNetwork(data.frame(id=V(Apollo)$name), edges, main = "Apollo",submain="Can zoom in/out to check the IDs and ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth =  FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>% 
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)

Apollo_interactive_layout 
```


### Centrality measures

```{r}
#function to calculate centrality metrics
find_highest_centrality <- function(graph){
  
  # highest degree
  degree <- degree(graph, mode = "all")
  node_degree <- V(graph)$name[which.max(degree)]
  
  # highest betweenness
  betweenness <- betweenness(graph, normalized = TRUE)
  node_betweenness <- V(graph)$name[which.max(betweenness)]
  
  # highest closeness
  closeness <- closeness(graph, mode = "all")
  node_closeness <- V(graph)$name[which.max(closeness)]
  
  # highest eigenvector
  eigen_centrality <- eigen_centrality(graph)$vector
  node_eigen <- V(graph)$name[which.max(eigen_centrality)]
  
  # combine results
  cat("Highest degree is node: ", node_degree, "\n")
  cat("Highest betweenness is node: ", node_betweenness, "\n")
  cat("Highest closeness is node: ", node_closeness, "\n")
  cat("Highest eigenvector is node: ", node_eigen, "\n")
}

find_highest_centrality(Apollo)
```
# Missing Data Part

## Impute missing data and fill in for 3 sims

```{r ampute and impute for 3 sims}

Apollo_tibble <- as_tibble(PartOfApollo_13)

mbased_finite_apollo <- list(
  MCAR = furrr::future_map(1:3, ~ { # map over 3 sims
    Apollo_tibble %>% 
      ampute(prop = .2, 
             mech = "MCAR", patterns = c(1,1,0)) %>% .$amp %>% 
      mice(m = 5, 
           maxit = 5,
           method = "pmm",
           print = F)
  }  , .options = furrr_options(seed = 123)),
  MAR = furrr::future_map(1:3, ~ { # map over 3 sims
    Apollo_tibble %>% 
      ampute(prop = .2, 
             mech = "MAR", patterns = c(1,1,0), type = "RIGHT") %>% .$amp %>% 
      mice(m = 5, 
           maxit = 5,
           method = "pmm",
           print = F)
  }, .options = furrr_options(seed = 123))
)

```

## Single Amputation

```{r single amputation}
MCAR_single <- ampute(Apollo_tibble, prop = .2, 
                      mech = "MCAR", patterns = c(1,1,0))

head(MCAR_single$amp)
```

## Analysis single amputation

### How much missing points in receiver 
```{r}
ini <- mice(MCAR_single$amp, maxit = 0)
ini$nmis
```
### Plot pattern missing data

```{r}
md.pattern(MCAR_single$amp)
```
### Flux plot
```{r}
fx <- fluxplot(MCAR_single$amp)
```

## Imputation missing values 

```{r}
MCAR_single_imp <- mice(MCAR_single$amp, m = 5, 
                        maxit = 5,
                        method = "pmm",
                        print = F)

# removing time as a predictor
pred <- MCAR_single_imp$pred
pred[ ,"time"] <- 0

MCAR_single_imp <- mice(MCAR_single$amp, m=5, 
                        maxit=5,
                        pred=pred,  
                        method = "pmm", 
                        print=F)


```

```{r}
# check if there are no loops
MCAR_single_imp |>
  complete("long") |>
  summarize(all(sender != receiver))
```

### Inspect imputation
```{r}
bwplot(MCAR_single_imp)
```


### Density plot imputation receiver column
```{r}
densityplot(MCAR_single_imp, lwd = 3)
```



### Scatterplot: Impact of imputation method on sender and receiver in MCAR_single_imp.
```{r}
xyplot(MCAR_single_imp, receiver ~ sender | .imp)
```

# REM Part

## REM on the original dataset

### Actor-based model 

```{r}
colnames(PartOfApollo_13) <- c("time", "actor1", "actor2")

reh<- remify::remify(edgelist = PartOfApollo_13, directed = TRUE, ordinal = TRUE, model = "actor")

sender_effects <- ~ indegreeSender()

receiver_effects <- ~ outdegreeReceiver() 

out_actor <- remstats(sender_effects = sender_effects, receiver_effects = receiver_effects, reh = reh)

print(out_actor)
```

### Tie based model 

```{r}
reh<- remify::remify(edgelist = PartOfApollo_13, directed = TRUE, ordinal = TRUE, model = "tie")

effects_tie <- ~psABBA()

out_tie <- remstats(tie_effects = effects_tie, reh = reh)

print(out_tie)
```

### Fit the model 

## REM on the imputed datasets

### Actor based model 

```{r}
# Loop over all imputed datasets within MCAR_single_imp
for (i in 1:5) {
  # Select the i-th imputed dataset
  dataset <- complete(MCAR_single_imp, i)
  
  # Convert the dataset to a data frame
  dataset <- as.data.frame(dataset)
  
  # Set column names
  colnames(dataset) <- c("time", "actor1", "actor2")
  
  # Create the REM model
  reh <- remify::remify(edgelist = dataset, directed = TRUE, ordinal = TRUE, model = "actor")
  
  # Define the actor based effects
  sender_effects <- ~ indegreeSender()
  receiver_effects <- ~ outdegreeReceiver()
  
  # Calculate the effects using remstats
  out_actor <- remstats(sender_effects = sender_effects, receiver_effects = receiver_effects, reh = reh)
  
  # Print results
  print(out_actor)
}

```

### Tie based model 

```{r}
# Loop over all imputed datasets within MCAR_single_imp
for (i in 1:5) {
  # Select the i-th imputed dataset
  dataset <- complete(MCAR_single_imp, i)
  
  # Convert the dataset to a data frame
  dataset <- as.data.frame(dataset)
  
  # Set column names
  colnames(dataset) <- c("time", "actor1", "actor2")
  
  # Create the REM model
  reh <- remify::remify(edgelist = dataset, directed = TRUE, ordinal = TRUE, model = "tie")
  
  # Define the tie-based effects
  tie_effects <- ~ psABBA()
  
  # Calculate the effects using remstats
  out_tie <- remstats(tie_effects = tie_effects, reh = reh)
  
  # Print results
  print(out_tie)
}

